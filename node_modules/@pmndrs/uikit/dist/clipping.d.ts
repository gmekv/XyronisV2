import { Signal } from '@preact/signals-core';
import { Matrix4, Plane, Vector3 } from 'three';
import type { Box3, Line3, Matrix3, Sphere, Vector2Tuple } from 'three';
import { FlexNodeState } from './flex/node.js';
import { RootContext } from './context.js';
export declare class ClippingRect {
    readonly planes: Array<Plane>;
    private readonly facePlane;
    private readonly originalCenter;
    constructor(globalMatrix: Matrix4, centerX: number, centerY: number, width: number, height: number);
    min({ planes }: ClippingRect): this;
    toArray(array: ArrayLike<number>, offset: number): void;
}
export declare function computedIsClipped(parentClippingRect: Signal<ClippingRect | undefined> | undefined, globalMatrix: Signal<Matrix4 | undefined>, size: Signal<Vector2Tuple | undefined>, pixelSizeSignal: Signal<number>): Signal<boolean>;
export declare function computedClippingRect(globalMatrix: Signal<Matrix4 | undefined>, { overflow, borderInset, size }: FlexNodeState, pixelSizeSignal: Signal<number>, parentClippingRect: Signal<ClippingRect | undefined> | undefined): Signal<ClippingRect | undefined>;
export declare const NoClippingPlane: Plane;
export declare const defaultClippingData: Float32Array;
export declare function createGlobalClippingPlanes(root: RootContext, clippingRect: Signal<ClippingRect | undefined>): RelativePlane[];
declare class RelativePlane implements Plane {
    private getLocalPlane;
    private getGlobalMatrix;
    get normal(): Vector3;
    get constant(): number;
    isPlane: true;
    constructor(getLocalPlane: () => Plane | undefined, getGlobalMatrix: () => Matrix4 | undefined);
    private computeInto;
    set(normal: Vector3, constant: number): Plane;
    setComponents(x: number, y: number, z: number, w: number): Plane;
    setFromNormalAndCoplanarPoint(normal: Vector3, point: Vector3): Plane;
    setFromCoplanarPoints(a: Vector3, b: Vector3, c: Vector3): Plane;
    clone(): this;
    copy(plane: Plane): this;
    normalize(): Plane;
    negate(): Plane;
    distanceToPoint(point: Vector3): number;
    distanceToSphere(sphere: Sphere): number;
    projectPoint(point: Vector3, target: Vector3): Vector3;
    intersectLine(line: Line3, target: Vector3): Vector3 | null;
    intersectsLine(line: Line3): boolean;
    intersectsBox(box: Box3): boolean;
    intersectsSphere(sphere: Sphere): boolean;
    coplanarPoint(target: Vector3): Vector3;
    applyMatrix4(matrix: Matrix4, optionalNormalMatrix?: Matrix3): Plane;
    translate(offset: Vector3): Plane;
    equals(plane: Plane): boolean;
    isIntersectionLine(l: any): any;
}
export {};
