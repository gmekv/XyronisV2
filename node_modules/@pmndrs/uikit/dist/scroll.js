import { computed, effect, signal } from '@preact/signals-core';
import { Box2, Matrix4, Vector2, Vector3 } from 'three';
import { computedBorderInset } from './utils.js';
import { clamp } from 'three/src/math/MathUtils.js';
import { createInstancedPanel } from './panel/instanced-panel.js';
import { ElementType, computedOrderInfo } from './order.js';
import { createPanelMaterialConfig } from './panel/panel-material.js';
import { defaultPanelDependencies } from './panel/instanced-panel-group.js';
const distanceHelper = new Vector3();
const localPointHelper = new Vector3();
export function createScrollPosition() {
    return signal([0, 0]);
}
export function computedGlobalScrollMatrix(scrollPosition, globalMatrix, pixelSizeSignal) {
    return computed(() => {
        const global = globalMatrix.value;
        if (global == null) {
            return undefined;
        }
        const [scrollX, scrollY] = scrollPosition.value;
        const pixelSize = pixelSizeSignal.value;
        return new Matrix4().makeTranslation(-scrollX * pixelSize, scrollY * pixelSize, 0).premultiply(global);
    });
}
export function applyScrollPosition(object, scrollPosition, pixelSizeSignal, initializers) {
    return initializers.push(() => effect(() => {
        const [scrollX, scrollY] = scrollPosition.value;
        const pixelSize = pixelSizeSignal.value;
        object.current?.position.set(-scrollX * pixelSize, scrollY * pixelSize, 0);
        object.current?.updateMatrix();
    }));
}
export function computedAnyAncestorScrollable(scrollable, anyAncestorScrollable) {
    return computed(() => {
        const [ancestorX, ancestorY] = anyAncestorScrollable?.value ?? [false, false];
        const [x, y] = scrollable.value;
        return [ancestorX || x, ancestorY || y];
    });
}
export function computedScrollHandlers(scrollPosition, anyAncestorScrollable, nodeState, object, scrollbarWidth, listeners, root, initializers) {
    const isScrollable = computed(() => nodeState.scrollable.value?.some((scrollable) => scrollable) ?? false);
    const downPointerMap = new Map();
    const scrollVelocity = new Vector2();
    const scroll = (event, deltaX, deltaY, deltaTime, enableRubberBand) => {
        if (scrollPosition.value == null) {
            return;
        }
        const [wasScrolledX, wasScrolledY] = event == null ? [false, false] : getWasScrolled(event.nativeEvent);
        if (wasScrolledX) {
            deltaX = 0;
        }
        if (wasScrolledY) {
            deltaY = 0;
        }
        const [x, y] = scrollPosition.value;
        const [maxX, maxY] = nodeState.maxScrollPosition.value;
        let [newX, newY] = scrollPosition.value;
        const [ancestorScrollableX, ancestorScrollableY] = anyAncestorScrollable?.value ?? [false, false];
        newX = computeScroll(x, maxX, deltaX, enableRubberBand && !ancestorScrollableX);
        newY = computeScroll(y, maxY, deltaY, enableRubberBand && !ancestorScrollableY);
        if (deltaTime != null && deltaTime > 0) {
            scrollVelocity.set(deltaX, deltaY).divideScalar(deltaTime);
        }
        if (event != null) {
            setWasScrolled(event.nativeEvent, wasScrolledX || Math.min(x, (maxX ?? 0) - x) > 5, wasScrolledY || Math.min(y, (maxY ?? 0) - y) > 5);
        }
        const preventScroll = listeners.peek()?.onScroll?.(newX, newY, scrollPosition, event);
        if (preventScroll === false || (x === newX && y === newY)) {
            return;
        }
        scrollPosition.value = [newX, newY];
    };
    const onFrame = (delta) => {
        if (downPointerMap.size > 0 || scrollPosition.value == null) {
            return;
        }
        let deltaX = 0;
        let deltaY = 0;
        const [x, y] = scrollPosition.value;
        const [maxX, maxY] = nodeState.maxScrollPosition.value;
        const outsideDistanceX = outsideDistance(x, 0, maxX ?? 0);
        const outsideDistanceY = outsideDistance(y, 0, maxY ?? 0);
        if (Math.abs(outsideDistanceX) > 1 || Math.abs(outsideDistanceY) > 1) {
            root.requestFrame();
        }
        deltaX += outsideDistanceX * -0.3;
        deltaY += outsideDistanceY * -0.3;
        deltaX += scrollVelocity.x * delta;
        deltaY += scrollVelocity.y * delta;
        scrollVelocity.multiplyScalar(0.9); //damping scroll factor
        if (Math.abs(scrollVelocity.x) < 10 /** px per second */) {
            scrollVelocity.x = 0;
        }
        else {
            root.requestFrame();
        }
        if (Math.abs(scrollVelocity.y) < 10 /** px per second */) {
            scrollVelocity.y = 0;
        }
        else {
            root.requestFrame();
        }
        if (deltaX === 0 && deltaY === 0) {
            return;
        }
        scroll(undefined, deltaX, deltaY, undefined, true);
    };
    initializers.push(() => effect(() => {
        if (!isScrollable.value) {
            return;
        }
        root.onFrameSet.add(onFrame);
        return () => root.onFrameSet.delete(onFrame);
    }));
    return computed(() => {
        if (!isScrollable.value) {
            return undefined;
        }
        const onPointerFinish = ({ pointerId, object }) => {
            if ('releasePointerCapture' in object && typeof object.releasePointerCapture === 'function') {
                object.releasePointerCapture(pointerId);
            }
            if (!downPointerMap.delete(pointerId) || downPointerMap.size > 0 || scrollPosition.value == null) {
                return;
            }
            //only request a render if the last pointer that was dragging stopped dragging and this panel is actually scrollable
            root.requestRender();
        };
        return {
            onPointerDown: ({ pointerId, point, nativeEvent, object: eventObject }) => {
                const isMouseInteraction = nativeEvent.pointerType === 'mouse';
                const localPoint = object.current.worldToLocal(point.clone());
                const scrollbarAxisIndex = !isMouseInteraction
                    ? undefined
                    : getIntersectedScrollbarIndex(localPoint, root.pixelSize.peek(), scrollbarWidth.peek(), nodeState.size.peek(), nodeState.maxScrollPosition.peek(), nodeState.borderInset.peek(), scrollPosition.peek());
                if (scrollbarAxisIndex != null) {
                    if ('setPointerCapture' in eventObject && typeof eventObject.setPointerCapture === 'function') {
                        eventObject.setPointerCapture(pointerId);
                    }
                    downPointerMap.set(pointerId, {
                        type: 'scroll-bar',
                        localPoint,
                        axisIndex: scrollbarAxisIndex,
                    });
                    return;
                }
                if (isMouseInteraction) {
                    return;
                }
                if ('setPointerCapture' in eventObject && typeof eventObject.setPointerCapture === 'function') {
                    eventObject.setPointerCapture(pointerId);
                }
                downPointerMap.set(pointerId, {
                    type: 'scroll-panel',
                    timestamp: performance.now() / 1000,
                    localPoint,
                });
            },
            onPointerUp: onPointerFinish,
            onPointerLeave: onPointerFinish,
            onPointerCancel: onPointerFinish,
            onPointerMove: (event) => {
                if (event.defaultPrevented) {
                    return;
                }
                const prevInteraction = downPointerMap.get(event.pointerId);
                if (prevInteraction == null) {
                    return;
                }
                object.current.worldToLocal(localPointHelper.copy(event.point));
                distanceHelper.copy(localPointHelper).sub(prevInteraction.localPoint);
                distanceHelper.divideScalar(root.pixelSize.peek());
                prevInteraction.localPoint.copy(localPointHelper);
                if (prevInteraction.type === 'scroll-bar') {
                    const size = nodeState.size.peek();
                    if (size == null) {
                        return;
                    }
                    //convert distanceHelper to (drag delta) * maxScrollPosition
                    toScrollbarScrollDistance(distanceHelper, prevInteraction.axisIndex, size, nodeState.borderInset.peek(), nodeState.maxScrollPosition.peek(), scrollbarWidth.peek());
                    scroll(event, distanceHelper.x, -distanceHelper.y, undefined, false);
                    return;
                }
                const timestamp = performance.now() / 1000;
                const deltaTime = timestamp - prevInteraction.timestamp;
                scroll(event, -distanceHelper.x, distanceHelper.y, deltaTime, true);
                prevInteraction.timestamp = timestamp;
            },
            onWheel: (event) => {
                if (event.defaultPrevented) {
                    return;
                }
                const { nativeEvent } = event;
                scroll(event, nativeEvent.deltaX, nativeEvent.deltaY, undefined, false);
            },
        };
    });
}
const wasScrolledSymbol = Symbol('was-scrolled');
function getWasScrolled(event) {
    return event[wasScrolledSymbol] ?? [false, false];
}
function setWasScrolled(event, x, y) {
    event[wasScrolledSymbol] = [x, y];
}
function computeScroll(position, maxPosition, delta, enableRubberBand) {
    if (delta === 0) {
        return position;
    }
    const outside = outsideDistance(position, 0, maxPosition ?? 0);
    if (sign(delta) === sign(outside)) {
        delta *= Math.max(0, 1 - Math.abs(outside) / 100);
    }
    let newPosition = position + delta;
    if (enableRubberBand && maxPosition != null) {
        return newPosition;
    }
    return clamp(newPosition, 0, maxPosition ?? 0);
}
function sign(value) {
    return value >= 0;
}
function outsideDistance(value, min, max) {
    if (value < min) {
        return value - min;
    }
    if (value > max) {
        return value - max;
    }
    return 0;
}
const scrollbarBorderPropertyKeys = [
    'scrollbarBorderLeftWidth',
    'scrollbarBorderRightWidth',
    'scrollbarBorderTopWidth',
    'scrollbarBorderBottomWidth',
];
export function createScrollbars(propertiesSignal, scrollPosition, flexState, globalMatrix, isVisible, parentClippingRect, orderInfo, panelGroupManager, scrollbarWidth, initializers) {
    const scrollbarOrderInfo = computedOrderInfo(undefined, ElementType.Panel, defaultPanelDependencies, orderInfo);
    const borderInset = computedBorderInset(propertiesSignal, scrollbarBorderPropertyKeys);
    createScrollbar(propertiesSignal, 0, scrollPosition, flexState, globalMatrix, isVisible, parentClippingRect, scrollbarOrderInfo, panelGroupManager, scrollbarWidth, borderInset, initializers);
    createScrollbar(propertiesSignal, 1, scrollPosition, flexState, globalMatrix, isVisible, parentClippingRect, scrollbarOrderInfo, panelGroupManager, scrollbarWidth, borderInset, initializers);
}
let scrollbarMaterialConfig;
function getScrollbarMaterialConfig() {
    scrollbarMaterialConfig ??= createPanelMaterialConfig({
        backgroundColor: 'scrollbarColor',
        borderBottomLeftRadius: 'scrollbarBorderBottomLeftRadius',
        borderBottomRightRadius: 'scrollbarBorderBottomRightRadius',
        borderTopRightRadius: 'scrollbarBorderTopRightRadius',
        borderTopLeftRadius: 'scrollbarBorderTopLeftRadius',
        borderColor: 'scrollbarBorderColor',
        borderBend: 'scrollbarBorderBend',
        borderOpacity: 'scrollbarBorderOpacity',
        backgroundOpacity: 'scrollbarOpacity',
    }, {
        backgroundColor: 0xffffff,
        backgroundOpacity: 1,
    });
    return scrollbarMaterialConfig;
}
function createScrollbar(propertiesSignal, primaryIndex, scrollPosition, flexState, globalMatrix, isVisible, parentClippingRect, orderInfo, panelGroupManager, scrollbarWidth, borderSize, initializers) {
    const scrollbarTransformation = computed(() => computeScrollbarTransformation(primaryIndex, scrollbarWidth.value, flexState.size.value, flexState.maxScrollPosition.value, flexState.borderInset.value, scrollPosition.value));
    const scrollbarPosition = computed(() => (scrollbarTransformation.value?.slice(0, 2) ?? [0, 0]));
    const scrollbarSize = computed(() => (scrollbarTransformation.value?.slice(2, 4) ?? [0, 0]));
    initializers.push((subscriptions) => createInstancedPanel(propertiesSignal, orderInfo, undefined, panelGroupManager, globalMatrix, scrollbarSize, scrollbarPosition, borderSize, parentClippingRect, isVisible, getScrollbarMaterialConfig(), subscriptions));
}
function computeScrollbarTransformation(primaryAxisIndex, secondaryScrollbarSize, size, maxScrollPosition, borderInset, scrollPosition) {
    if (size == null || borderInset == null || scrollPosition == null) {
        return undefined;
    }
    const primaryMaxScrollPosition = maxScrollPosition[primaryAxisIndex];
    if (primaryMaxScrollPosition == null) {
        return undefined;
    }
    const result = [0, 0, 0, 0];
    const endInsetIndex = 1 - primaryAxisIndex;
    const primarySizeWithoutBorder = size[primaryAxisIndex] - borderInset[endInsetIndex] - borderInset[endInsetIndex + 2];
    const primaryScrollbarSize = computePrimaryScrollbarSize(primarySizeWithoutBorder, primaryMaxScrollPosition, secondaryScrollbarSize);
    const primaryMaxScrollbarPosition = primarySizeWithoutBorder - primaryScrollbarSize;
    const primaryScrollPosition = scrollPosition[primaryAxisIndex];
    //position
    const invertedIndex = 1 - primaryAxisIndex;
    result[primaryAxisIndex] =
        size[primaryAxisIndex] * 0.5 -
            primaryScrollbarSize * 0.5 -
            borderInset[(primaryAxisIndex + 3) % 4] -
            primaryMaxScrollbarPosition * clamp(primaryScrollPosition / primaryMaxScrollPosition, 0, 1);
    result[invertedIndex] = size[invertedIndex] * 0.5 - secondaryScrollbarSize * 0.5 - borderInset[invertedIndex + 1];
    if (primaryAxisIndex === 0) {
        result[0] *= -1;
        result[1] *= -1;
    }
    //size
    result[primaryAxisIndex + 2] = primaryScrollbarSize;
    result[endInsetIndex + 2] = secondaryScrollbarSize;
    return result;
}
function computePrimaryScrollbarSize(primarySizeWithoutBorder, primaryMaxScrollPosition, secondaryScrollbarSize) {
    return Math.max(secondaryScrollbarSize, (primarySizeWithoutBorder * primarySizeWithoutBorder) / (primaryMaxScrollPosition + primarySizeWithoutBorder));
}
/**
 * @param target contains the delta movement in pixels and will receive the delta scroll distance in pixels
 */
function toScrollbarScrollDistance(target, primaryAxisIndex, size, borderInset, maxScrollPosition, secondaryScrollbarSize) {
    const primaryMaxScrollPosition = maxScrollPosition[primaryAxisIndex];
    if (size == null || borderInset == null || primaryMaxScrollPosition == null) {
        return;
    }
    const delta = target.getComponent(primaryAxisIndex);
    const primarySizeWithoutBorder = size[primaryAxisIndex] - borderInset[1 - primaryAxisIndex] - borderInset[1 - primaryAxisIndex + 2];
    const primaryScrollbarSize = computePrimaryScrollbarSize(primarySizeWithoutBorder, primaryMaxScrollPosition, secondaryScrollbarSize);
    const primaryMaxScrollbarPosition = primarySizeWithoutBorder - primaryScrollbarSize;
    target.setComponent(primaryAxisIndex, (delta / primaryMaxScrollbarPosition) * primaryMaxScrollPosition);
    target.setComponent(1 - primaryAxisIndex, 0);
    target.z = 0;
}
const box2Helper = new Box2();
const point2Helper = new Vector2();
function getIntersectedScrollbarIndex(point, pixelSize, secondaryScrollbarSize, size, maxScrollPosition, borderInset, scrollPosition) {
    if (size == null) {
        return undefined;
    }
    point2Helper.copy(point).divideScalar(pixelSize);
    for (let i = 0; i < 2; i++) {
        if (intersectsScrollbar(point2Helper, i, secondaryScrollbarSize, size, maxScrollPosition, borderInset, scrollPosition)) {
            return i;
        }
    }
    return undefined;
}
const centerHelper = new Vector2();
const sizeHelper = new Vector2();
function intersectsScrollbar(point, axisIndex, secondaryScrollbarSize, size, maxScrollPosition, borderInset, scrollPosition) {
    const result = computeScrollbarTransformation(axisIndex, secondaryScrollbarSize, size, maxScrollPosition, borderInset, scrollPosition);
    if (result == null) {
        return false;
    }
    box2Helper.setFromCenterAndSize(centerHelper.fromArray(result, 0), sizeHelper.fromArray(result, 2));
    return box2Helper.containsPoint(point);
}
