var _a;
import { PRIVATE as ENTITY_PRIVATE, Entity } from './Entity';
export const PRIVATE = Symbol('@elics/entity-pool');
export class EntityPool {
    constructor(world) {
        this[_a] = {
            world: null,
            pool: [],
            entityIndex: new Map(),
        };
        this[PRIVATE].world = world;
        this[PRIVATE].entityIndex = new Map();
    }
    getEntity() {
        let entity;
        if (this[PRIVATE].pool.length > 0) {
            entity = this[PRIVATE].pool.pop();
            entity[ENTITY_PRIVATE].active = true;
        }
        else {
            entity = new Entity(this[PRIVATE].world);
        }
        // this.updateEntityIndex(entity);
        return entity;
    }
    returnEntity(entity) {
        this[PRIVATE].pool.push(entity);
        this.removeFromEntityIndex(entity);
    }
    updateEntityIndex(entity) {
        const mask = entity[ENTITY_PRIVATE].componentMask;
        if (!this[PRIVATE].entityIndex.has(mask)) {
            this[PRIVATE].entityIndex.set(mask, new Set());
        }
        this[PRIVATE].entityIndex.get(mask).add(entity);
    }
    removeFromEntityIndex(entity) {
        var _b;
        // call this method before an entity is destroyed
        const mask = entity[ENTITY_PRIVATE].componentMask;
        (_b = this[PRIVATE].entityIndex.get(mask)) === null || _b === void 0 ? void 0 : _b.delete(entity);
    }
    getEntities(query) {
        let matchingEntities = [];
        this[PRIVATE].entityIndex.forEach((entities, mask) => {
            if (query.matchesMask(mask)) {
                matchingEntities.push(...entities);
            }
        });
        return matchingEntities;
    }
}
_a = PRIVATE;
//# sourceMappingURL=EntityPool.js.map