var _a$6;
const PRIVATE$6 = Symbol('@elics/query');
class Query {
    constructor({ required, excluded = [] }) {
        this[_a$6] = {
            requiredComponents: new Set(),
            excludedComponents: new Set(),
            queryId: '',
        };
        this[PRIVATE$6].requiredComponents = new Set(required.map((c) => c.bitmask || 0));
        this[PRIVATE$6].excludedComponents = new Set(excluded.map((c) => c.bitmask || 0));
        this[PRIVATE$6].queryId = Query.generateQueryId(this[PRIVATE$6].requiredComponents, this[PRIVATE$6].excludedComponents);
    }
    static generateQueryId(requiredComponents, excludedComponents) {
        const requiredMask = Array.from(requiredComponents).reduce((acc, val) => acc | val, 0);
        const excludedMask = Array.from(excludedComponents).reduce((acc, val) => acc | val, 0);
        return `required:${requiredMask}|excluded:${excludedMask}`;
    }
    static matchesQuery(queryId, mask) {
        const [requiredPart, excludedPart] = queryId.split('|');
        const requiredMask = parseInt(requiredPart.split(':')[1]);
        const excludedMask = parseInt(excludedPart.split(':')[1]);
        if ((mask & requiredMask) !== requiredMask) {
            return false;
        }
        // Skip the excluded mask check if excludedMask is 0 (no components to exclude)
        if (excludedMask !== 0 && (mask & excludedMask) === excludedMask) {
            return false;
        }
        return true;
    }
    get queryId() {
        return this[PRIVATE$6].queryId;
    }
}
_a$6 = PRIVATE$6;

var _a$5;
const PRIVATE$5 = Symbol('@elics/system');
class System {
    constructor(world, queryManager, priority = 0) {
        this[_a$5] = {
            world: null,
            queryManager: null,
            isPaused: false,
            priority: 0,
            queries: {},
        };
        this[PRIVATE$5].world = world;
        this[PRIVATE$5].queryManager = queryManager;
        this[PRIVATE$5].priority = priority;
    }
    get world() {
        return this[PRIVATE$5].world;
    }
    get isPaused() {
        return this[PRIVATE$5].isPaused;
    }
    get queries() {
        return this[PRIVATE$5].queries;
    }
    get priority() {
        return this[PRIVATE$5].priority;
    }
    getEntities(query) {
        return this[PRIVATE$5].queryManager.getEntities(query);
    }
    init() {
        // Override in derived systems
    }
    update(_delta, _time) {
        // Override in derived systems
    }
    play() {
        this[PRIVATE$5].isPaused = false;
    }
    stop() {
        this[PRIVATE$5].isPaused = true;
    }
}
_a$5 = PRIVATE$5;
System.isSystem = true;
System.queries = {};

var _a$4;
const PRIVATE$4 = Symbol('@elics/component');
class Component {
    reset() {
        // noop
    }
    constructor(componentManager, index, initialData = {}) {
        this[_a$4] = {
            componentManager: null,
            index: null,
        };
        this[PRIVATE$4].componentManager = componentManager;
        this[PRIVATE$4].index = index;
        Object.assign(this, this.constructor.defaults);
        Object.assign(this, initialData);
    }
}
_a$4 = PRIVATE$4;
Component.bitmask = null;
Component.defaults = {};

var _a$3;
const PRIVATE$3 = Symbol('@elics/component-manager');
class ComponentManager {
    constructor() {
        this[_a$3] = {
            componentPools: new Map(),
            freeInstances: new Map(),
        };
    }
    registerComponent(ComponentClass) {
        this[PRIVATE$3].componentPools.set(ComponentClass.bitmask, []);
        this[PRIVATE$3].freeInstances.set(ComponentClass.bitmask, []);
    }
    requestComponentInstance(ComponentClass, initialData = {}) {
        const pool = this[PRIVATE$3].componentPools.get(ComponentClass.bitmask);
        const free = this[PRIVATE$3].freeInstances.get(ComponentClass.bitmask);
        if (!pool || !free) {
            throw new Error('Component class not registered');
        }
        // If there are free instances, use one
        if (free.length > 0) {
            const index = free.pop();
            const instance = pool[index];
            Object.assign(instance, ComponentClass.defaults);
            Object.assign(instance, initialData);
            return instance;
        }
        else {
            const newInstance = new ComponentClass(this, pool.length, initialData);
            pool.push(newInstance);
            return newInstance;
        }
    }
    releaseComponentInstance(componentInstance) {
        const ComponentClass = componentInstance.constructor;
        const pool = this[PRIVATE$3].componentPools.get(ComponentClass.bitmask);
        const free = this[PRIVATE$3].freeInstances.get(ComponentClass.bitmask);
        if (!pool || !free) {
            throw new Error('Component class not registered');
        }
        // Reset the component
        componentInstance.reset();
        // Add the index back to the free queue
        free.push(componentInstance[PRIVATE$4].index);
    }
}
_a$3 = PRIVATE$3;

var _a$2;
const PRIVATE$2 = Symbol('@elics/entity-manager');
class EntityManager {
    constructor(world) {
        this[_a$2] = {
            world: null,
            pool: [],
        };
        this[PRIVATE$2].world = world;
    }
    requestEntityInstance() {
        let entity;
        if (this[PRIVATE$2].pool.length > 0) {
            entity = this[PRIVATE$2].pool.pop();
            entity.active = true;
        }
        else {
            const entityPrototype = this[PRIVATE$2].world[PRIVATE].entityPrototype;
            entity = new entityPrototype(this[PRIVATE$2].world);
        }
        return entity;
    }
    releaseEntityInstance(entity) {
        this[PRIVATE$2].pool.push(entity);
    }
}
_a$2 = PRIVATE$2;

var _a$1;
const PRIVATE$1 = Symbol('@elics/query-manager');
class QueryManager {
    constructor() {
        this[_a$1] = {
            queries: new Map(),
        };
    }
    registerQuery(query) {
        const identifier = query.queryId;
        if (!this[PRIVATE$1].queries.has(identifier)) {
            this[PRIVATE$1].queries.set(identifier, new Set());
        }
    }
    updateEntity(entity) {
        if (entity.componentMask === 0) {
            // Remove entity from all query results if it has no components
            this[PRIVATE$1].queries.forEach((entities) => entities.delete(entity));
            return;
        }
        this[PRIVATE$1].queries.forEach((entities, queryId) => {
            const matches = Query.matchesQuery(queryId, entity.componentMask);
            const isInResultSet = entities.has(entity);
            if (matches && !isInResultSet) {
                entities.add(entity);
            }
            else if (!matches && isInResultSet) {
                entities.delete(entity);
            }
        });
    }
    getEntities(query) {
        const identifier = query.queryId;
        if (!this[PRIVATE$1].queries.has(identifier)) {
            throw new Error(`Query not registered: ${identifier}`);
        }
        return Array.from(this[PRIVATE$1].queries.get(identifier) || []);
    }
}
_a$1 = PRIVATE$1;

var _a;
const PRIVATE = Symbol('@elics/world');
class World {
    constructor() {
        this[_a] = {
            entityManager: new EntityManager(this),
            queryManager: new QueryManager(),
            componentManager: new ComponentManager(),
            nextComponentTypeId: 0,
            systems: [],
            entityPrototype: Entity,
        };
    }
    setEntityPrototype(prototype) {
        this[PRIVATE].entityPrototype = prototype;
    }
    registerComponent(componentClass) {
        const typeId = 1 << this[PRIVATE].nextComponentTypeId;
        this[PRIVATE].nextComponentTypeId++;
        if (this[PRIVATE].nextComponentTypeId >= 32) {
            throw new Error('Exceeded the maximum number of unique components');
        }
        componentClass.bitmask = typeId;
        this[PRIVATE].componentManager.registerComponent(componentClass);
        return this;
    }
    createEntity() {
        return this[PRIVATE].entityManager.requestEntityInstance();
    }
    registerSystem(systemClass, priority) {
        if (this[PRIVATE].systems.some((system) => system instanceof systemClass)) {
            throw new Error('System already registered');
        }
        const systemInstance = new systemClass(this, this[PRIVATE].queryManager, priority);
        Object.entries(systemClass.queries).forEach(([queryName, queryConfig]) => {
            const query = new Query(queryConfig);
            this[PRIVATE].queryManager.registerQuery(query);
            systemInstance[PRIVATE$5].queries[queryName] = query;
        });
        systemInstance.init();
        // Determine the correct position for the new system based on priority
        const insertIndex = this[PRIVATE].systems.findIndex((s) => s[PRIVATE$5].priority > systemInstance[PRIVATE$5].priority);
        if (insertIndex === -1) {
            this[PRIVATE].systems.push(systemInstance);
        }
        else {
            this[PRIVATE].systems.splice(insertIndex, 0, systemInstance);
        }
        return this;
    }
    unregisterSystem(systemClass) {
        this[PRIVATE].systems = this[PRIVATE].systems.filter((system) => !(system instanceof systemClass));
    }
    registerQuery(queryConfig) {
        const query = new Query(queryConfig);
        this[PRIVATE].queryManager.registerQuery(query);
        return this;
    }
    update(delta, time) {
        this[PRIVATE].systems.forEach((system) => {
            if (!system[PRIVATE$5].isPaused) {
                system.update(delta, time);
            }
        });
    }
    getSystem(systemClass) {
        for (const system of this[PRIVATE].systems) {
            if (system instanceof systemClass) {
                return system;
            }
        }
        return undefined;
    }
    getSystems() {
        return [...this[PRIVATE].systems];
    }
}
_a = PRIVATE;

const ERRORS = {
    MODIFY_DESTROYED_ENTITY: 'Cannot modify a destroyed entity',
    ACCESS_DESTROYED_ENTITY: 'Cannot access a destroyed entity',
};
class Entity {
    constructor(world) {
        this.componentMask = 0;
        this.active = true;
        this.components = new Map();
        this.entityManager = world[PRIVATE].entityManager;
        this.queryManager = world[PRIVATE].queryManager;
        this.componentManager = world[PRIVATE].componentManager;
    }
    addComponent(componentClass, initialData = {}) {
        if (!this.active)
            throw new Error(ERRORS.MODIFY_DESTROYED_ENTITY);
        if (componentClass.bitmask !== null) {
            this.componentMask |= componentClass.bitmask;
            const componentInstance = this.componentManager.requestComponentInstance(componentClass, initialData);
            this.components.set(componentClass, componentInstance);
            this.queryManager.updateEntity(this);
            return componentInstance;
        }
        else {
            throw new Error('Component type not registered');
        }
    }
    removeComponent(componentClass) {
        if (!this.active)
            throw new Error(ERRORS.MODIFY_DESTROYED_ENTITY);
        if (componentClass.bitmask !== null &&
            this.components.has(componentClass)) {
            const componentInstance = this.components.get(componentClass);
            this.componentManager.releaseComponentInstance(componentInstance);
            this.componentMask &= ~componentClass.bitmask;
            this.components.delete(componentClass);
            this.queryManager.updateEntity(this);
        }
        else {
            throw new Error('Component not found');
        }
    }
    hasComponent(componentClass) {
        if (!this.active)
            throw new Error(ERRORS.ACCESS_DESTROYED_ENTITY);
        return this.components.has(componentClass);
    }
    getComponent(componentClass) {
        if (!this.active)
            throw new Error(ERRORS.ACCESS_DESTROYED_ENTITY);
        const component = this.components.get(componentClass);
        if (!component)
            return null;
        return component;
    }
    getComponentTypes() {
        if (!this.active)
            throw new Error(ERRORS.ACCESS_DESTROYED_ENTITY);
        return Array.from(this.components.keys());
    }
    destroy() {
        if (!this.active)
            throw new Error(ERRORS.MODIFY_DESTROYED_ENTITY);
        this.entityManager.releaseEntityInstance(this);
        // Mark the entity as inactive
        this.active = false;
        // Clear the components map and reset the component mask
        this.components.forEach((component) => {
            this.componentManager.releaseComponentInstance(component);
        });
        this.components.clear();
        this.componentMask = 0;
        this.queryManager.updateEntity(this);
    }
}

export { Component, Entity, Query, System, World };
